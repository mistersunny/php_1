<?php
$title = 'Третье домашнее задание';
$year = date('Y');
?>

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title><?= $title ?></title>
</head>
<body>
<?php
header("Content-Type: text/html; charset=UTF-8");
/**
 * 1. С помощью цикла while вывести все числа в промежутке 
 * от 0 до 100, которые делятся на 3 без остатка.
 */
echo 'Задание 1.<br/>';

$i=0;//первое число диапазона
$n=100;//последнее число диапазона

while ($i <= $n) {
  while($n % 3 !=0) {// если правая граница диапазона не является последним числом делящимся на 3 без остатка
    $n--;//то уменьшаем правую границу диапазона на 1
  }
  if ($i % 3 == 0 && $i != $n){// если число делится на 3 без остатка и это не последнее число в диапазоне,то
    echo $i , ', ';//выводим это число с запятой
  }
  if ($i % 3 == 0 && $i == $n) {// если число делится на 3 без остатка и это последнее число в диапазоне,то
    echo $i , ".";////выводим это число с точкой
  }
  $i++;//увеличиваем счетчик на 1
}
echo '<br/>';
/**
 * 2. С помощью цикла do…while написать функцию для вывода чисел 
 * от 0 до 10, чтобы результат выглядел так: 
 * 0 – это ноль.
 * 1 – нечётное число.
 * 2 – чётное число.
 * 3 – нечётное число.
 * …
 * 10 – чётное число.
 */
echo '<br/>Задание 2.<br/>';

$a = 0;
do {
  if ($a == 0) {
    echo $a , ' - это ноль.<br/>';
  } else {
    echo $a , ($a % 2 == 1 ? ' - это нечетное число.' :' - это четное число.') , '<br/>';
  }
    $a++;
} while ($a <= 10);

/**
 * 3. Объявить массив, в котором в качестве ключей будут использоваться 
 * названия областей, а в качестве значений – массивы с названиями 
 * городов из соответствующей области.
 * Вывести в цикле значения массива, чтобы результат был таким:
 * Московская область:
 * Москва, Зеленоград, Клин.
 * Ленинградская область:
 * Санкт-Петербург, Всеволожск, Павловск, Кронштадт.
 * Рязанская область…(названия городов можно найти на maps.yandex.ru)
 */
echo '<br/>Задание 3.<br/>';

$cities = ['Амурская'     => ['Благовещенск' , 'Белогорск' , 'Свободный' , 'Тында'],
           'Архангельская' => ['Архангельск' , 'Вельск' , 'Каргополь' , 'Корязьма'],
           'Астраханская' => ['Астрахань' , 'Ахтубинск' , 'Камызяк', 'Нариманов'],
           'Белгородская' => ['Белгород' , 'Бируч' , 'Валуйки' , 'Короча']
];
foreach ($cities as $obl => $goroda) {
    echo $obl , ' область:<br/>';
    foreach ($goroda as $gorod) echo ($gorod == end($goroda) ? "$gorod." : "$gorod, ");
    echo '<br/>';
}

/**
 * 4. Объявить массив, индексами которого являются буквы русского языка, 
 * а значениями – соответствующие латинские буквосочетания 
 * (‘а’=> ’a’, ‘б’ => ‘b’, ‘в’ => ‘v’, ‘г’ => ‘g’, …, ‘э’ => ‘e’, 
 * ‘ю’ => ‘yu’, ‘я’ => ‘ya’).
 * Написать функцию транслитерации строк.
 */
echo '<br/>Задание 4.<br/>';

$rus_alphabet = ['а','б','в','г','д','е','ё','ж','з','и','й','к','л','м','н','о','п','р','с','т','у','ф','х','ц','ч','ш','щ','ъ','ы','ь','э','ю','я'];
$eng_alphabet = ['a','b','v','g','d','e','yo','zh','z','i','y','k','l','m','n','o','p','r','s','t','u','f','h','c','ch','sh','shh','``','y`','`','e`','yu','ya'];
$translit = array_combine($rus_alphabet, $eng_alphabet);

function transliterate($str) {
global $translit;//открываем доступ к массиву находящемуся вне функции
$arr = preg_split('//u', $str, -1, PREG_SPLIT_NO_EMPTY); // преобразуем строку в массив
foreach ($arr as &$value) { // для каждого элемента массива перезаписываем его значение
  if (isset($translit[$value])) {//если в массиве translit есть ключ с таким названием
    $value = $translit[$value];//то текущему элементу присваиваем значение соответсвующее этому ключу
  }
  if (preg_match('~^[А-ЯЁ\W\d]+$~u', $value)) {//проверяем является ли буква заглавной, если да, то
    $value = mb_strtolower($value, 'UTF-8');//меняем регистр на нижний
    if (isset($translit[$value])) {//если в массиве translit есть ключ с таким названием
        $value = $translit[$value];//то текущему элементу присваиваем значение соответсвующее этому ключу
    }
    $value = mb_strtoupper($value, 'UTF-8');//меняем регистр на верхний
  }
}
return $str = implode($arr);//возвращаем строку полученную объединением элементов массива
    // либо такой вариант
    // global $eng_alphabet;//открываем доступ к массиву находящемуся вне функции
    // global $rus_alphabet;//открываем доступ к массиву находящемуся вне функции
    // $arr = preg_split('//u', $str, -1, PREG_SPLIT_NO_EMPTY); // преобразуем строку в массив
    // foreach ($arr as &$value) {//обходим все буквы в массиве и перезаписываем их значения
    //   if (preg_match('~^[А-ЯЁ\W\d]+$~u', $value)) {//проверяем является ли буква заглавной, если да, то
    //     $value = mb_strtolower($value, 'UTF-8');//меняем регистр на нижний
    //     $value = str_replace($rus_alphabet, $eng_alphabet, $value);//заменяем русскую букву английской
    //     $value = mb_strtoupper($value, 'UTF-8');//меняем регистр на верхний
    //   }
    //   $value = str_replace($rus_alphabet, $eng_alphabet, $value);//заменяем русскую букву английской
    // }
    // return $str = implode($arr);//возвращаем строку полученную объединением элементов массива
  }
echo $stroka1 = "Hello, World 123 Привет из Йошкар-Олы!"  , '<br/>';
echo transliterate($stroka1) , '<br/>';

/**
 * 5. Написать функцию, которая заменяет в строке пробелы на подчеркивания 
 * и возвращает видоизмененную строчку.
 */
echo '<br/>Задание 5.<br/>';

function probel($str){
  return $str = str_replace(' ', '_', $str);
}
echo $stroka2 = 'Stroka s probelami' , '<br/>';
echo probel($stroka2) , '<br/>';

/**
 * 6. В имеющемся шаблоне сайта заменить статичное меню 
 * (ul - li) на генерируемое через PHP. Необходимо 
 * представить пункты меню как элементы массива и 
 * вывести их циклом. Подумать, как можно реализовать 
 * меню с вложенными подменю? Попробовать его реализовать.
 */
echo '<br/>Задание 6.<br/>';

$menu = ['Home' , 'Info' => ['news' , 'stocks' , 'events'] , 'Contacts' , 'About us'];

foreach ($menu as $key => $value) {
  if ($key == array_key_first($menu) && is_int($key)){//если текущий ключ равен первому ключу массива menu и имеет целочисленное значение
    echo "<ul>";// то открываем ul
  }
  if (is_array($value)) {// если текущее значение массив то
    echo "<li> $key <ul>";// открываем тэг li выводим текущий ключ открываем тег ul 
    foreach ($value as $val){ // для каждого элемента массива
      echo "<li> $val </li>";// выводим значение этого элемента в теге li
    }
    echo "</ul></li>";//закрываем тег ul и закрываем тег li
  } else {//если текущее значение не массив то
      echo "<li> $value </li>";//выводим текущее значение в теге li
  }
  if ($key == array_key_last($menu)){// если текущий ключ равен последнему ключу массива menu
    echo "</ul>";// то закрываем тег ul
  }
}
/**
 * 7. Вывести с помощью цикла for числа от 0 до 9, 
 * НЕ используя тело цикла. Выглядеть это должно так:
 * for(…){// здесь пусто}
 */
echo '<br/>Задание 7.<br/>';

for ($i = 0; $i <= 9; print $i++ . ' ') {}
echo '<br/>';
/**
 * 8. *Повторить третье задание, но вывести на 
 * экран только города, начинающиеся с буквы «К».
 */
echo '<br/>Задание 8.<br/>';

foreach ($cities as $obl => $goroda) {// для каждого массива городов проверяем
    if (strpos(implode($goroda), 'К') !== false) {//если в строке склееной из значений массива городов есть буква К, то
      echo $obl , ' область:<br/>';//выводим название этой области
      unset ($towns);// удаляем переменную towns
      foreach ($goroda as $gorod) {//для каждой такой области проверяем города
          if (mb_substr($gorod, 0, 1) == "К") {//если первая буква названия города К, то
            $towns[] = $gorod; //добавляем этот город в массив towns, таким образом он будет содержать все города данной области начинающиеся с буквы К
          }
      }
      foreach ($towns as $town){// каждый элемент массива towns 
        echo ($town == end($towns) ? "$town." : "$town, ");// выводим на экран через запятую, а после последнего элемента ставим точку
      }
      echo '<br/>';
    }
}

/**
 * 9. *Объединить две ранее написанные функции в одну, 
 * которая получает строку на русском языке, производит 
 * транслитерацию и замену пробелов на подчеркивания 
 * (аналогичная задача решается при конструировании 
 * url-адресов на основе названия статьи в блогах).
 */
echo '<br/>Задание 9.<br/>';

function unite ($str){
  $str = preg_replace("/[^a-zа-я0-9\s]/iu" , "" , $str);
  return probel(transliterate($str));
}
echo ($stroka1) , '<br/>';
echo unite($stroka1);
?>
</body>
    <footer><br>А на дворе уже <?= $year?>-й год.</footer>
</html>